Installing CUDD
---------------

1. Download CUDD 3.0.0 from here: http://vlsi.colorado.edu/~fabio/
2. unpack the archive
3. In folder cudd-3.0.0 call the following steps to get the 32-bit library with dddmp and c++-wrapper (if you do not want 32 bit, omit "CFLAGS=-m32" "CXXFLAGS=-m32" "LDFLAGS=-m32"):
  - ./configure --prefix=/home/salone/progs/cudd/ --enable-shared --enable-dddmp --enable-obj --enable-static "CFLAGS=-m32" "CXXFLAGS=-m32" "LDFLAGS=-m32"
  - make
  - make install
4. Move the following two header files to <path-to-cudd>/include:
  - config.h
  - util/util.h
  (No, I don't know why this is necessary, but else the dddmp library complains...)
5. In your .bashrc export the path to the CUDD library:
   "export export DOWNWARD_CUDD_ROOT=<path-to-cudd>
6. Compile Fast Downward with ./build.py (choose a 32 bit compilation if you compiled the library in 32 bit)
7. Compile the verifier by calling make in the src/unsolvability directory (you need to change the Makefile if you want a 64 bit compilation)



Generating and verifying certificates
-------------------------------------

The script run in src/unsolvability executes the following steps needed to
create and verify a certificate:

1. It runs the planner (currently in m&s configuration) which will create
   a certificate and a task file
2. It runs verify in src/unsolvability with input task.txt and certificate.txt 
   (generated by step 1)

---FORMATS---

--------------------------------------------------------------------------------
The task description has the following format:
--------------------------------------------------------------------------------
________________________________________________________________________________
begin_atoms:<#atoms>
<atom 1>
<atom 2>
... (list all atoms, one each row)
end_atoms
begin_init
<initital state atom 1>
<initital state atom 2>
... (lists atoms that are true in initial state, one each row)
end_init
begin_goal
<goal atom 1>
<goal atom 2>
... (lists atoms that are true in goal, one each row)
end_goal
begin_actions:<#actions>
begin_action
<action_name>
cost: <action_cost>
PRE:<preconditionatom 1>
... (more PRE)
ADD:<added atom 1>
... (more ADD)
DEL:<deleted atom 1>
... (more DEL)
end_action
... (lists all actions)
end_actions
________________________________________________________________________________

TODO: rework this section!
--------------------------------------------------------------------------------
The "master" certificate describes one of 3 certificate types:
--------------------------------------------------------------------------------
Note: the variables occuring in the master certificate must all occur in
the task description as well (else the certificate would use atoms which are
not in the task). They are listed here because the variable ordering might be
different for each certificate and since the bdd is saved with only indexes
as variables we need to know which variable each index denotes.

1) SIMPLE CERTIFICATE: This type of certificate consists of a single bdd
(saved in bdd file) with the given variable ordering.
________________________________________________________________________________
simple_certificate
File:<bdd file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
end_certificate
________________________________________________________________________________

2) STRONG CONJUNCTIVE CERTIFICATE: This type of certificate consists of
multiple bdds (saved in (1!) bdd file) which all share the given variable
ordering.
________________________________________________________________________________
strong_conjunctive_certificate
File:<bdd file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
end_certificate
________________________________________________________________________________

3) SEARCH CERTIFICATE: This type of certificate consists of 1 bdd denoting
all expanded states (saved in bdd_exp file) with the given variable ordering,
and arbitraty many subcertificates (of type simple certificate or strong
conjunctive certificate). These subcertificates should cover _all_ dead_ends
encountered in the search and should be inductive in respect to the task.
________________________________________________________________________________
search_certificate
File:<bdd_exp file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
subcertificates:<#subcertificates>
simple_certificate
...
end_certificate
strong_conjunctive_certificate
...
end_certificate
...
end_subcertificates
end_certificate
________________________________________________________________________________
