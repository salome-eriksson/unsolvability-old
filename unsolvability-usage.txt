Installing CUDD
---------------

1. Download CUDD 3.0.0 from here: http://vlsi.colorado.edu/~fabio/
2. unpack the archive
3. In folder cudd-3.0.0 call the following steps to get the 32-bit library
   with dddmp and c++-wrapper (if you do not want 32 bit, omit "CFLAGS=-m32"
   "CXXFLAGS=-m32" "LDFLAGS=-m32"):
  - ./configure --prefix=/home/salone/progs/cudd/ --enable-shared --enable-dddmp --enable-obj --enable-static "CFLAGS=-m32" "CXXFLAGS=-m32" "LDFLAGS=-m32"
  - make
  - make install
4. Move the following two header files to <path-to-cudd>/include:
  - config.h
  - util/util.h
  (I don't know why this is necessary, but else the dddmp library complains...)
5. In your .bashrc export the path to the CUDD library:
   "export export DOWNWARD_CUDD_ROOT=<path-to-cudd>
6. In the Makefile under src/unsolvability, add your CUDD path in the beginning
7. Compile Fast Downward with ./build.py (choose a 32 bit compilation if you
   compiled the library in 32 bit)
8. Compile the verifier by calling make in the src/unsolvability directory
   (you need to change the Makefile if you want a 64 bit compilation)


Generating and verifying certificates
-------------------------------------

The script run in src/unsolvability executes the following steps needed to
create and verify a certificate:

1. It runs the planner (currently in m&s configuration) which will create
   a certificate and a task file
2. It runs verify in src/unsolvability with input task.txt and certificate.txt 
   (generated by step 1)



---FORMATS---

The task description has the following format:
________________________________________________________________________________
begin_atoms:<#atoms>
<atom 1>
<atom 2>
... (list all atoms (by name), one each row)
end_atoms
begin_init
<initital state atom index 1>
<initital state atom index 2>
... (lists atoms (by index) that are true in initial state, one each row)
end_init
begin_goal
<goal atom index 1>
<goal atom index 2>
... (lists atoms (by index) that are true in goal, one each row)
end_goal
begin_actions:<#actions>
begin_action
<action_name>
cost: <action_cost>
PRE:<preconditionatom index 1>
... (more PRE)
ADD:<added atom index 1>
... (more ADD)
DEL:<deleted atom index 1>
... (more DEL)
end_action
... (lists all actions)
end_actions
________________________________________________________________________________


The "master" certificate "certificate.txt" contains the following information:
________________________________________________________________________________
certificate-type:simple|disjunctive:r|conjunctive:r
bdd-files:<# of bdd files>
<list of bdd files>
(hints:<name of hints file>)
________________________________________________________________________________

each bdd-file contains of 0-n of the following blocks:

<#bdds> <list of indices separated by space>
<bdd_dump>

The dump must contain exactly #bdds bdds. In the verifier each bdd is associated
with a unique index, such that all bdds are saved in a map and can be easily
accessed and crossreferenced.

The hint-file is intended for conjunctive/disjunctive certificates. It tells
for a bdd and for an action which bdds are associated with it. It is not
necessary but will make the verification process a lot faster. The file
contains of lines with the following format:
<bdd-index> <#hints> <actionindex> <bddindex>:---:<bddindex> ...
It must end with the following line:
end_hints

Example: 0 4 87 1 0 2 29 3 58 4
This line says that for bdd 0 we have 4 hints:
 1. for action 87 the corresponding bdd is 1
 2. for action 0 the corresponding bdd is 2
 3. for action 29 the corresponding bdd is 3
 4. for action 58 the corresponding bdd is 4

Example 2: 2 3 43 2:42:3 23 1:2 4 53
This line says that for bdd 2 we have 3 hints:
 1. for action 43 the corresponding bdds are 2,42 and 3
 2. for action 23 the corresponding bdds are 1 and 2
 3. for action 4 the corresponding bdd is 53
 
Note that for each bdd there can only be 1 such line. If no hint exist for
a bdd and action, then the verifier will first test if the bdd is inductive
for that action, otherwise it will test it with the union/cut depending
on the certificate type. If the certificate type is bounded by r, it will
consider all unions/cuts of size r.
