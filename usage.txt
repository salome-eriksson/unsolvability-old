The script run in src/unsolvability executes the following steps needed to
create and verify a certificate:

1. It runs the planner (currently in m&s configuration) which will create
   a certificate
2. It runs instantiate.py in src/unsolvability/translate in order to get a
   grounded task description
3. It runs verify in src/unsolvability with input task.txt (generated by
   step 2) and certificate.txt (generated by step 1)

---FORMATS---

--------------------------------------------------------------------------------
The task description has the following format:
--------------------------------------------------------------------------------
________________________________________________________________________________
begin_atoms:<#atoms>
<atom 1>
<atom 2>
... (list all atoms, one each row)
end_atoms
begin_init
<initital state atom 1>
<initital state atom 2>
... (lists atoms that are true in initial state, one each row)
end_init
begin_goal
<goal atom 1>
<goal atom 2>
... (lists atoms that are true in goal, one each row)
end_goal
begin_actions:<#actions>
begin_action
<action_name>
cost: <action_cost>
PRE:<preconditionatom 1>
... (more PRE)
ADD:<added atom 1>
... (more ADD)
DEL:<deleted atom 1>
... (more DEL)
end_action
... (lists all actions)
end_actions
________________________________________________________________________________


--------------------------------------------------------------------------------
The "master" certificate describes one of 3 certificate types:
--------------------------------------------------------------------------------
Note: the variables occuring in the master certificate must all occur in
the task description as well (else the certificate would use atoms which are
not in the task). They are listed here because the variable ordering might be
different for each certificate and since the bdd is saved with only indexes
as variables we need to know which variable each index denotes.

1) SIMPLE CERTIFICATE: This type of certificate consists of a single bdd
(saved in bdd file) with the given variable ordering.
________________________________________________________________________________
simple_certificate
File:<bdd file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
end_certificate
________________________________________________________________________________

2) STRONG CONJUNCTIVE CERTIFICATE: This type of certificate consists of
multiple bdds (saved in (1!) bdd file) which all share the given variable
ordering.
________________________________________________________________________________
strong_conjunctive_certificate
File:<bdd file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
end_certificate
________________________________________________________________________________

3) SEARCH CERTIFICATE: This type of certificate consists of 1 bdd denoting
all expanded states (saved in bdd_exp file) with the given variable ordering,
and arbitraty many subcertificates (of type simple certificate or strong
conjunctive certificate). These subcertificates should cover _all_ dead_ends
encountered in the search and should be inductive in respect to the task.
________________________________________________________________________________
search_certificate
File:<bdd_exp file>
begin_variables
<atom 1>
<atom 2>
...
end_variables
subcertificates:<#subcertificates>
simple_certificate
...
end_certificate
strong_conjunctive_certificate
...
end_certificate
...
end_subcertificates
end_certificate
________________________________________________________________________________
